- go mod init [nome do modulo] - para iniciar o modulo e poder importar bibliotecas.

- CTRL + C - para interromper o terminal em andamento

- Função(func) main só pode ter uma por pacote(package).

- Quando se cria uma função com a primeira letra maiúscula ela pode ser utilizada em outro arquivo, e uma função com a primeira 
  letra minúscula não pode.

- var numero2 uint32 = -10
  uint não pega número negativo

  alias - termo utilizado
  int32 == rune

  alias - termo utilizado
  uint8 == byte

- aspas simples é o mais próximo de Char.

- var erro error = errors.New("Inválido")
    erro = nome da variável
    error = tipo da variável
    erros = nome do pacote

- inferência de tipos (variavel2 := Variável 2)

- Pode declarar a inferência de tipo assim - numero := float32(10.5)

- O tanto de espaço que você colocar antes ou após uma aspa ele irá obdecer e será utilizado.

- fmt.Println(variavel5 + variavel6) = irá concatenar (juntar) e apresentar as duas variáveis.
- fmt.Println(variavel5, variavel6) = irá separar por um espaço e apresentar as duas variaveis.

- A constante não precisa necessariamente ser utilizada igual uma variável, posso somente cria-la e não utiliza-la, 
  porém é uma boa prática manter apenas as que estão e irão ser utilizadas.

- Em go você pode retornar dois valores na mesma função.

- Em uma função de receber valores, o _ (underline) pode ser utilizado para ignorar o valor, e vai ser 
  inexistente sem receber o valor.

- Não pode somar números que tem o tipo de dado diferente, como exemplo:
  var numero1 int16 = 10
  var numero2 int32 = 8
  soma := numero1 + numero2

- Pode usar inferência de tipos com duas variáveis com tipos de dados iguais, como exemplo:
  var numero1 int16 = 10
	var numero2 int16 = 8
	soma2 := numero1 + numero2

- Ponteiro é uma referência de memória
    *int (pode ser int, float, string) - identifica que é uma criação de um ponteiro 
    &variavel3 - utilizar esse "&" faz com que pegue a referência daquela variável
    *variavel4 - utilizar esse "*" (asterisco) é uma desreferênciação,
	  pois ele irá pegar o valor da variável e não o local onde está alocada
    exemplo:
      var variavel3 int = 10
	    var variavel4 *int = &variavel3
      fmt.Println(*variavel4)

- A diferença da criação de um array pra um slice é no definição de elementos,
	pois no slice não se define tamanho e no array sim

- Slice é uma fatia de um array.
    append(slice, ...) - adiciona mais um ou vários elementos dentro do slice e aumenta sua capacidade.
	  len(slice) - número de elementos dentro do slice.
	  cap(slice) - capacidade máxima de números dentro do slice, porém com append(slice, ...) você pode aumentar essa capacidade.

- Slice pode ser criado pegando todos os valores de um array e adicionando mais alguns.

- Após a capacidade do slice ser estourada o Go vai aumentar um de tamanho (len - lenght) e dobrar sua capacidade.

- Slice pode ser criado com o make sem o parametro de capacidade.

- if init - if outroNumero := numero; outroNumero > 0 

  fmt.Println(outroNumero) - a variável criada no if init não pode ser acessada fora do seu if criado.

- fallthrough(utilizado no switch) - utilizado para que seja executado/apresentado/armazenado seja o próximo item do switch
  sem precisar verificar se o próximo item está correto ou não.
  exemplo:
  numero = 1
  case numero == 1:
		diaDaSemana = "Domingo"
		fallthrough // nesse caso o diaDaSemana armazenado seria "Segunda", por conta do fallthrough
	case numero == 2:
		diaDaSemana = "Segunda"

- o for possui 4 modos, para memorizar (for while, for normal, for range, for infinito)
    for while - for i < 10 { }
    for normal - for i := 0; i < 10; i++ { }
    for range - for indice, valor := range nomes { }
    for infito - for { }

- No for range pode ser utilizado por arrays, slices e maps, como exemplos:
  arrays e slices:
  nomes := []string{"João", "Davi", "José"}
	for indice, nomes := range nomes {
		fmt.Println(indice, nomes)
	}

  maps:
    usuario := map[string]string{
		"nome":      "Leonardo",
		"sobrenome": "Leoncio",
	}
  for chave, valor := range usuario {
		fmt.Println(chave, valor)
	}

- Não pode utilizar for range em struct

- As funções variáticas o parametro que recebe varios valores é um slice - func soma(numeros ...int) int,
  fazendo que possamos utilizar o for range para manipulação de dados

- Uma função variática só pode ter um parametro váriatico por função e se por acaso tiver 2 ou mais, 
  ele tem que ser o ultimo parametro, exemplo:
  
func escrever(texto string, numeros ...int) {
	for _, numero := range numeros {
		fmt.Println(texto, numero)
	}
}

- defer - utilizado para adiar alguma parte do código e deixar para o final.

- panic - utilizado para se algo acontecer dar um panico e a execução ser interrompida na mesma hora, e 
  caso houver um defer com uma recover o código não vai ser interrompido.

- recover - utilizado para recuperar e não fazer a execução ser parada pelo panic.

- Função(func) init é inicializada primeiro que a função(func) main, e ele pode ter 1 por arquivo,
  diferente da função main que só pode ter uma por pacote (package).

- CONCORRÊNCIA != PARALELISMO

- goroutine (go) - utilizado para mesmo que o aquele comando chamado não tenha terminado, já pode ir para a próxima linha
  executar o próximo comando.

- Métodos para usar o chanel (canal):

  for {
		mensagem, aberto := <-canal // <-canal - esperando que o canal receba um valor
		if !aberto {
			break
		}
		fmt.Println(mensagem)
	}

  // outro método de printar o canal
	for mensagem2 := range canal {
		fmt.Println(mensagem2)
	}

- Métodos para usar o chanel com buffer:
  canal := make(chan string, 2)
	canal <- "Olá mundo!"
	canal <- "Programando em Go"

	mensagem := <-canal
	mensagem2 := <-canal

	fmt.Println(mensagem)
	fmt.Println(mensagem2)

- A função test dentro do Go foi feita justamente para se fazer testes e verificar se está tudo correto
  em seu programa.

- Pode ser Criado vários funções de teste com nome começando com Test, no arquivo [nome_do_arquivo]_test.go

- t.Parallel() - utilizado para fazer funções em paralelo, tem que ser colocado no inicio de cada função

- go test -v (utilizado no terminal)- para mostrar todos os testes feitos no _test.go

- go test --cover (utilizado no terminal)- para saber se o nosso teste está cobrindo todos os casos de teste da função chamada

- go test --coverprofile [nome_do_arquivo].txt (utilizado no terminal)- para criar um arquivo onde possa saber oque não está sendo 
  coberto pelo test

- go tool cover --func=[none_do_arquivo].txt (utilizado no terminal)- para ler o arquivo.txt e 
  falar algumas informações sobre oque não foi coberto

- go tool cover --html=[none_do_arquivo].txt (utilizado no terminal)- informações mais detalhadas e faceis de vizualizar, 
  sendo mostrado em html no google

- JSON é utilizado para armazenar e transportar dados de um lugar pro outro, como mandar dados de um servidor para
  uma página web ou vice-versa.

- json.Marshal() - utilizado para converter um map ou struct para um json, retorna 2 valores (valores e erro)

- json.Unmarshal() - utilizado para converter um json para um map ou struct 

- json.Marshal() retorna um slice de bytes e o json.Unmarshal recebe um slice de bytes.

- bytes.NewBuffer() - utilizado para conversão de bytes em strings, por exemplo em json.Marshal() pois retorna valores em byte.

- Fatal é um erro que após ser apresentado ele já encerra o programa

- Error são valores que representam uma condição de erro, mas não necessariamente impedem 
  o programa de continuar sua execução

- HTTP É UM PROTOCOLO DE COMUNICAÇÃO - BASE DA COMUNICAÇÃO WEB

- CLIENTE (FAZ REQUISIÇÃO) - SERVIDOR (PROCESSA REQUISIÇÃO E ENVIA RESPOSTA)
	  O cliente faz uma requisição onde o servidor vai processar essa requisição e vai devolver uma resposta
	  Request - Response

- Rotas - Identificar o tipo de mensagem que está sendo enviada e
  identificar que tipo de processamento o servidor vai fazer em cima da mensagem
  
- Rotas 
    URI - Identificador do recurso
    Método - GET, POST, PUT, DELETE

- Normalmente se utiliza rota com parametro para o Get com id ({id}), Put e para o Delete.

- Quando utilizar insert into (inserir os dados) se utiliza db.Prepare.
- Quando utilizar select (selecionar dados) se utiliza db.Query.